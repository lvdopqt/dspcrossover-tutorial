# ESP32 - First Program

With the development environment ready, we can start programming the software. To avoid starting from absolute zero, we’ll use the library [https://github.com/Wei1234c/SigmaDSP](https://github.com/Wei1234c/SigmaDSP) as a base. The _SigmaDSP_ repository is a Python package developed to control the ADAU1401 and ADAU1701 digital audio processors from a PC or ESP32. It allows reading SigmaStudio project XML files and creating proxy objects that represent SigmaStudio Toolbox algorithms, enabling dynamic adjustments of parameters such as frequency, dB level, and filter coefficients. The project’s goal is to enable automatic filter coefficient adjustments without relying solely on SigmaStudio, making the control more flexible and compatible with multiple platforms, including Windows, Linux, Raspberry Pi, and ESP32.

However, due to the project’s generic nature, it is not ideal for embedded applications where resource limitations are a fundamental constraint. Therefore, for our specific application, we will only use the communication interface with the DSP, which was developed to facilitate communication between the ESP32 and the ADAU1401. I created a fork of the project to simplify the import of this relevant part for a more specific application: [https://github.com/lvdopqt/sigmadsp_minimal](https://github.com/lvdopqt/sigmadsp_minimal).

## Initial Setup

Let’s start by creating a folder for our project and cloning the `sigmadsp_minimal` repository inside it. To do this, run the following commands in the terminal:

```bash
mkdir dsp_application
cd dsp_application
git clone https://github.com/lvdopqt/sigmadsp_minimal
```

*If you don’t have Git installed, follow this tutorial: [https://github.com/git-guides/install-git](https://github.com/git-guides/install-git).

## Initializing the Project

Now that the repository has been cloned, we can open the code editor of your choice and start developing the software. The first step is to create a file called `main.py`, which will be the entry point of our application. In this file, we’ll import the library we just cloned and configure communication with the DSP using the I2C protocol.

```python
from machine import SoftI2C, Pin

from sigmadsp_minimal.sigma_dsp.adau.adau1401.adau1401 import ADAU1401 as ADAU
from sigmadsp_minimal.bus.adapters import I2C as SigmaI2C

DSP_SCL_PIN = 26
DSP_SDA_PIN = 27
I2C_FREQ = 400000

dsp_i2c = SoftI2C(scl=Pin(DSP_SCL_PIN), sda=Pin(DSP_SDA_PIN), freq=I2C_FREQ)
bus = SigmaI2C(dsp_i2c)
dsp = ADAU(bus)
```

To configure communication between the ESP32 and the ADAU1401 DSP, we start by importing the necessary libraries and modules. The `machine` module, native to the ESP32, provides the `SoftI2C` and `Pin` functions, which are essential for configuring I2C communication and controlling the microcontroller’s pins. Additionally, we import the `ADAU1401` class from the `sigmadsp_minimal` library, which represents the audio processor, and the `I2C` interface, renamed as `SigmaI2C`, to adapt the I2C communication to the format expected by the library.

Next, we define the ESP32 pins used for I2C communication. The `DSP_SCL_PIN` (26) is responsible for the clock signal (SCL), while the `DSP_SDA_PIN` (27) is used for the data signal (SDA). The I2C bus frequency is set to 400 kHz, a common value to ensure fast and stable communication.

With the pins configured, we initialize the I2C bus using the `SoftI2C` function. This function takes the SCL and SDA pins, as well as the operating frequency, as parameters, creating an instance of the I2C bus ready for use. Then, we use the `SigmaI2C` class to adapt this instance to the format expected by the `sigmadsp_minimal` library, ensuring compatibility with the library’s functions.

Finally, we create an instance of the ADAU1401 DSP using the `ADAU` class and passing the configured I2C bus as a parameter. This instance allows direct interaction with the audio processor, dynamically adjusting parameters such as frequency, gain, and filter coefficients. With this configuration complete, the ESP32 is ready to communicate with the DSP and control audio processing flexibly.

## DSP Parameters

Now let’s use the `.params` file generated by SigmaStudio. We generated it in part 3 of this tutorial, but if you haven’t generated it yet, go to your project in SigmaStudio > Export System Data.  
This file contains the following information:

``` 
Cell Name         = Crossover1
Parameter Name    = CrossoverFilter2WayAlgSP1B0_0
Parameter Address = 1
Parameter Value   = 0.00102317333221436
Parameter Data :
0x00 ,	0x00 ,	0x21 ,	0x87 ,	
```

- **Cell Name**: Refers to the name of the cell or functional block in SigmaStudio. In this case, `Crossover1` indicates that it is a crossover.
- **Parameter Name**: Represents the name of the specific parameter being configured. Here, `CrossoverFilter2WayAlgSP1B0_0` refers to one of the filter coefficients of the crossover, which is part of the audio processing algorithm.
- **Parameter Address**: This is the memory address in the DSP where the parameter is located. The value `1` indicates the specific position in the DSP’s memory where this coefficient will be stored or modified.
- **Parameter Value**: Corresponds to the numerical value of the parameter being configured. In this case, `0.00102317333221436` is the value of the filter coefficient, which directly influences the crossover’s behavior.
- **Parameter Data**: Represents the parameter value in raw data format (hexadecimal) stored in the DSP’s memory. Here, `0x00, 0x00, 0x21, 0x87` are the bytes encoding the parameter value in the format expected by the DSP hardware.

The most important information for our application is the **Parameter Name** and **Parameter Address**. If we observe the parameter file used, each two-way crossover represented in SigmaStudio has 20 filtering parameters (four sets of B0, B1, B2, A1, and A2) and one parameter to invert the polarity of the high frequency.

## Introduction to Biquad Filters

Before proceeding with configuring the DSP parameters, it’s important to understand the concept of biquad filters, which are widely used in digital audio processing. A biquad filter is a type of digital filter that implements a second-order transfer function, capable of performing operations such as equalization, crossover, noise suppression, and more. It is called "biquad" because its transfer function can be expressed as a ratio of two quadratic polynomials.

The structure of a biquad filter is defined by five main coefficients: B0, B1, B2, A1, and A2. These coefficients determine the filter’s behavior, such as cutoff frequency, gain, and filter type (low-pass, high-pass, band-pass, etc.). In SigmaStudio, these coefficients are automatically calculated based on the filter settings you define in the graphical interface, but when working directly with the DSP, we can adjust them programmatically to customize audio processing.

The mathematical structure of a biquad filter is based on its **transfer function**, which describes how the filter processes the input signal to produce the output signal. This transfer function is expressed as a **ratio of two quadratic polynomials**, meaning a fraction where both the numerator and denominator are second-order polynomials. The general form of a biquad filter’s transfer function is:

<img src="../Images/Pasted image 20250130193526.png"/>

The numerator (the top part of the function, where the b’s are) determines the **zeros** of the filter, while the denominator (the bottom part) determines the **poles**. The zˆ-1 terms represent a one-sample delay.  
The biquad filter is also commonly represented in the following graphical form:  
<img src="../Images/Pasted image 20250130194149.png"/>

### Poles and Zeros

- **Zeros**: The zeros of a filter are the roots of the numerator polynomial. They represent the frequencies at which the filter completely attenuates the input signal (i.e., the gain is zero). The location of the zeros in the complex plane directly influences the filter’s frequency response, especially in the stopband regions.
- **Poles**: The poles are the roots of the denominator polynomial. They determine the frequencies at which the filter can amplify or resonate the input signal. The position of the poles in the complex plane defines the filter’s stability and its frequency response in the passband regions. For the filter to be stable, all poles must lie within the unit circle in the complex plane, but don’t worry about this for now! This information is here just to inform you that it’s possible to create filters that can become unstable when defining these parameters. An unstable filter can lead the filter’s gain to "infinity," which in some sound systems can cause damage.

### Frequency Response

The frequency response of a biquad filter is determined by the interaction between its poles and zeros. For example:

- A **low-pass filter** will have poles that reinforce low frequencies and zeros that attenuate high frequencies.
- A **high-pass filter** will have poles that reinforce high frequencies and zeros that attenuate low frequencies.
- A **band-pass filter** will have poles and zeros positioned to reinforce a specific frequency range while attenuating others.

## Implementing Filter Coefficient Calculations

Analog Devices provides a document on how to calculate coefficients for different filters:  
[https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/1307.FilterMathCalculations.pdf](https://ez.analog.com/cfs-file/__key/communityserver-wikis-components-files/00-00-00-01-75/1307.FilterMathCalculations.pdf)

Let’s implement a simple first-order Butterworth high-pass and low-pass filter based on this document! The filter definitions are shown below:  

<img src="../Images/Pasted image 20250130195415.png"/>

Now let’s rewrite this in MicroPython:

```python
from math import sin, cos, pi

def butterworth_lowpass(frequency, fs, g):
    # Gain calculation
    gain = 10 ** (g / 20)
    
    # Initial variable calculations
    omega = 2 * pi * frequency / fs
    sn = sin(omega)
    cs = cos(omega)
    a0 = sn + cs + 1
    
    # Low-pass filter coefficient calculation
    A1 = (sn - cs - 1) / a0
    B0 = gain * sn / a0
    B1 = gain * sn / a0
    
    # Return coefficients in the desired format
    return {'B0': B0, 'B1': B1, 'B2': 0, 'A1': A1, 'A2': 0}

def butterworth_highpass(frequency, fs, g):
    # Gain calculation
    gain = 10 ** (g / 20)
    
    # Initial variable calculations
    omega = 2 * pi * frequency / fs
    sn = sin(omega)
    cs = cos(omega)
    a0 = sn + cs + 1
    
    # High-pass filter coefficient calculation
    A1 = (sn - cs - 1) / a0
    B0 = gain * (1 + cs) / a0
    B1 = -gain * (1 + cs) / a0
    
    # Return coefficients in the desired format
    return {'B0': B0, 'B1': B1, 'B2': 0, 'A1': A1, 'A2': 0}
```

The usage of these functions would be as follows:

```python
# Example usage for the low-pass filter
lowpass_coeffs = butterworth_lowpass(1000, 44100, 6)
print("Low-pass filter coefficients:", lowpass_coeffs)

# Example usage for the high-pass filter
highpass_coeffs = butterworth_highpass(1000, 44100, 6)
print("High-pass filter coefficients:", highpass_coeffs)
```

Note that since these are first-order filters, the A2 and B2 parameters are 0.

## Writing Coefficients to the DSP

Now that we can calculate the coefficients, let’s create a complete version of our `main.py`!

```python 
from machine import SoftI2C, Pin
from sigmadsp_minimal.sigma_dsp.adau.adau1401.adau1401 import ADAU1401 as ADAU
from sigmadsp_minimal.bus.adapters import I2C as SigmaI2C
from math import sin, cos, pi

# I2C communication configuration with the DSP
DSP_SCL_PIN = 26
DSP_SDA_PIN = 27
I2C_FREQ = 400000

dsp_i2c = SoftI2C(scl=Pin(DSP_SCL_PIN), sda=Pin(DSP_SDA_PIN), freq=I2C_FREQ)
bus = SigmaI2C(dsp_i2c)
dsp = ADAU(bus)

# Functions for calculating Butterworth filter coefficients
def butterworth_lowpass(frequency, fs, g):
    # Gain calculation
    gain = 10 ** (g / 20)
    
    # Initial variable calculations
    omega = 2 * pi * frequency / fs
    sn = sin(omega)
    cs = cos(omega)
    a0 = sn + cs + 1
    
    # Low-pass filter coefficient calculation
    A1 = (sn - cs - 1) / a0
    B0 = gain * sn / a0
    B1 = gain * sn / a0
    
    # Return coefficients in the desired format
    return {'B0': B0, 'B1': B1, 'B2': 0, 'A1': A1, 'A2': 0}

def butterworth_highpass(frequency, fs, g):
    # Gain calculation
    gain = 10 ** (g / 20)
    
    # Initial variable calculations
    omega = 2 * pi * frequency / fs
    sn = sin(omega)
    cs = cos(omega)
    a0 = sn + cs + 1
    
    # High-pass filter coefficient calculation
    A1 = (sn - cs - 1) / a0
    B0 = gain * (1 + cs) / a0
    B1 = -gain * (1 + cs) / a0
    
    # Return coefficients in the desired format
    return {'B0': B0, 'B1': B1, 'B2': 0, 'A1': A1, 'A2': 0}

# Function to configure the filter on the DSP
def configure_filter(dsp, frequency, fs, g, address):
    # Calculate coefficients for high-pass and low-pass filters
    highpass_coeffs = butterworth_highpass(frequency, fs, g)
    lowpass_coeffs = butterworth_lowpass(frequency, fs, g)
    
    # Combine coefficients into a single list in the correct order
    coefficients = [
        highpass_coeffs['B0'], highpass_coeffs['B1'], highpass_coeffs['B2'],
        highpass_coeffs['A1'], highpass_coeffs['A2'],
        lowpass_coeffs['B0'], lowpass_coeffs['B1'], lowpass_coeffs['B2'],
        lowpass_coeffs['A1'], lowpass_coeffs['A2']
    ]
    
    # Convert coefficients to bytes and write to DSP memory
    bytes_array = b''.join([dsp.DspNumber(v).bytes for v in coefficients])
    dsp.parameter_ram.write(bytes_array=bytes_array, address=address)

# Example filter configuration
frequency = 1000  # Cutoff frequency in Hz
fs = 44100        # Sampling rate in Hz
g = 6             # Gain in dB
address = 1       # Memory address in the DSP where coefficients will be written

configure_filter(dsp, frequency, fs, g, address)
```

In summary:

This code is an implementation for configuring Butterworth audio filters (low-pass and high-pass) on an ADAU1401 digital signal processor (DSP) using an ESP32 microcontroller. The first part of the code configures I2C communication between the ESP32 and the DSP, defining the pins and operating frequency. Next, two functions, `butterworth_lowpass` and `butterworth_highpass`, are created to calculate the coefficients of first-order filters based on the specified cutoff frequency, sampling rate, and gain. These functions return the coefficients in dictionary format, including the terms B0, B1, A1, and setting B2 and A2 to zero since these are first-order filters.

The `configure_filter` function uses the coefficient calculation functions to generate the parameters for the high-pass and low-pass filters, combining them into a single list in the correct order. These coefficients are then converted to bytes and written to the DSP’s memory at the specified address. In the final example, the code configures a filter with a cutoff frequency of 1000 Hz, a sampling rate of 44100 Hz, and a gain of 6 dB, writing the coefficients to address `1` of the DSP. This approach allows dynamic adjustment of audio processing without relying on external tools like SigmaStudio.

## Conclusion

This project demonstrated how to implement **programmable audio filters** on an ADAU1401 DSP using an ESP32, combining flexibility and efficiency for embedded applications. By using the `sigmadsp_minimal` library, we simplified I2C communication with the DSP and eliminated exclusive reliance on SigmaStudio, enabling dynamic adjustments of filter coefficients directly via code.

The `butterworth_lowpass` and `butterworth_highpass` functions illustrate how to calculate coefficients for first-order Butterworth filters, while the `configure_filter` function integrates these calculations with writing to the DSP’s memory. This approach not only optimizes limited resources in embedded systems but also opens doors for advanced customizations, such as real-time adjustments or the implementation of more complex filters (like band-pass or shelving filters).

With the structure in place, the next step would be to expand the code to support **higher-order filters** or integrate user interfaces (such as buttons or Wi-Fi control), transforming the system into a versatile solution for real-time audio processing. The final code, available in the forked repository, serves as a foundation for projects requiring autonomous control over digital signal processors, consolidating itself as a practical alternative to the traditional workflow based on graphical tools.